//
//  HabitListInteractor.swift
//  EcoApp
//
//  Created by Artem on 28.04.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import ParseSwift



protocol HabitListBusinessLogic
{
    func make(request: HabitList.Request)
    func mockHabits(count: Int)
    func mockFacts()
    func mockLikes()
}

protocol HabitListDataStore
{
}

class HabitListInteractor: HabitListBusinessLogic, HabitListDataStore
{
  var presenter: HabitListPresentationLogic?
  var worker = HabitListWorker()
    
    
    func make(request: HabitList.Request) {
        guard appDelegate.isConnectedToServer() else {
            let res = HabitList.Response(type: .failure(.notConnected))
            presenter?.presentResponse(response: res)
            return
        }
        
        // проверяем авторизацию
        if request.type.requireAuth {
            guard let _ = User.current else {
                let res = HabitList.Response(type: .failure(.ubauthorized))
                presenter?.presentResponse(response: res)
                return
            }
        }

        switch request.type {
        case .getHabits:
            getHabitList()
        case .likeHabit(let habit):
            likeHabit(habit: habit)
        case .dislikeHabit(let habit):
            dislikeHabit(habit: habit)
        case .addFact(let habit):
            setHabitFact(habit: habit)
        case .getChallenges:
            getChallenges()
        }
    }
    
    func getHabitList() {
        
        let measureFetch = Date()
        let cloud = GetHabitsCloud(habitId: nil)
        cloud.runFunction { [weak self] result in
            switch result {
            case .success(let habits):
                Log("habits count \(habits.count)", type: .info)
                Log("measure fetch: \(Date().timeIntervalSince(measureFetch))", type: .warning)
                let measureSave = Date()
                for habit in habits {
                    habit.saveHabit()
                }
                appDelegate.saveContext()
                Log("measure save: \(Date().timeIntervalSince(measureSave))", type: .warning)
                let type = HabitList.getHabits(habits: habits)
                let res = HabitList.Response(type: .success(type))
                self?.presenter?.presentResponse(response: res)
            case .failure(let error):
                let res = HabitList.Response(type: .failure(.parseError(error: error)))
                self?.presenter?.presentResponse(response: res)
            }
        }
    }
    
    func likeHabit(habit: Habit) {
        let cloud = LikeHabitCloud(habit: habit,
                          frequency: habit.frequency!)
        cloud.runFunction { [weak self] result in
            switch result {
            case .success(let habit):
                habit.saveHabit()
                appDelegate.saveContext()
                let type = HabitList.likeHabit(habit: habit)
                let res = HabitList.Response(type: .success(type))
                self?.presenter?.presentResponse(response: res)
            case .failure(let error):
                let res = HabitList.Response(type: .failure(.parseError(error: error)))
                self?.presenter?.presentResponse(response: res)
            }
        }
    }
    
    func dislikeHabit(habit: Habit) {

        let cloud = DislikeHabitCloud(habit: habit)
        cloud.runFunction { [weak self] result in
            switch result {
            case .success(let habit):
                habit.saveHabit()
                appDelegate.saveContext()
                let type = HabitList.dislikeHabit(habit: habit)
                let res = HabitList.Response(type: .success(type))
                self?.presenter?.presentResponse(response: res)
            case .failure(let error):
                let res = HabitList.Response(type: .failure(.parseError(error: error)))
                self?.presenter?.presentResponse(response: res)
            }
        }
    }
        
    func setHabitFact(habit: Habit) {
        let cloud = CreateFactCloud(habit: habit)
        cloud.runFunction { [weak self] result in
            switch result {
            case .success(let habit):
                habit.saveHabit()
                appDelegate.saveContext()
                let type = HabitList.addFact(habit: habit)
                let res = HabitList.Response(type: .success(type))
                self?.presenter?.presentResponse(response: res)
            case .failure(let error):
                let res = HabitList.Response(type: .failure(.parseError(error: error)))
                self?.presenter?.presentResponse(response: res)
            }
        }
    }
    
    func getChallenges() {
        let cloud = ChallengesCloud(challengeId: nil)
        cloud.runFunction { [weak self] result in
            switch result {
            case .success(let challenges):
                print(challenges.flatMap{ $0.habits })
//                let type = HabitList.addFact(habit: habit)
//                let res = HabitList.Response(type: .success(type))
//                self?.presenter?.presentResponse(response: res)
            case .failure(let error):
                let res = HabitList.Response(type: .failure(.parseError(error: error)))
                self?.presenter?.presentResponse(response: res)
            }
        }
    }
    
    
    func mockFacts() {
        worker.mockFacts()
    }
    func mockLikes() {
        worker.mockLikes()
    }
    func mockHabits(count: Int) {
        worker.mockHabits(count: count)
    }
}


struct LikeHabitCloud: ParseCloud {
    typealias ReturnType = Habit
    var functionJobName = "likeHabit"
    var habit: Habit
    var frequency: Int
}

struct ChallengesCloud: ParseCloud {
    typealias ReturnType = [Challenge]
    var functionJobName = "getChallenges"
    var challengeId: Int?
}

struct DislikeHabitCloud: ParseCloud {
    typealias ReturnType = Habit
    var functionJobName = "dislikeHabit"
    var habit: Habit
}

struct CreateFactCloud: ParseCloud {
    typealias ReturnType = Habit
    var functionJobName = "createFact"
    var habit: Habit
}

struct GetHabitsCloud: ParseCloud {
    typealias ReturnType = [Habit]
    var functionJobName = "getHabits"
    var habitId: String?
}

struct HasAdminRoleCloud: ParseCloud {
    typealias ReturnType = Bool
    var functionJobName = "isAdmin"
}
